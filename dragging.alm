theory window_motion
    module dragging
        sort declarations
            windows :: universe
            % directions is a set comprised of the atoms left, right, top, and bottom.
            directions :: { left, right, top, bottom }
            % axes is a set comprised of the atoms x and y.
            axes :: { x, y }
            drag :: actions
                attributes
                    target : windows
                    offset : axes -> integers
        function declarations
            statics
                oppositeDirection : directions -> directions
                oppositeAxis : axes -> axes
                axis : directions -> axes
                directionFactor : directions -> { -1, 1 }
            fluents
                basic
                    total id : windows -> integers
                    total coordinate : windows x axes -> integers
                    total width : windows -> integers
                    total height : windows -> integers
                defined
                    total edge : windows x directions -> integers
                    total onSameLine : windows x windows x axes -> booleans
                    distance : windows x windows x directions -> integers
                    nearestEdge : windows x windows -> directions
                    cannotSnap : windows x windows x directions -> booleans
                    canSnap : windows x windows x directions -> booleans
                    possibleCoordinate : windows x axes -> integers
        axioms
            %%%%%% Static Relationships %%%%%%%%
            oppositeDirection(left) = right.
            oppositeDirection(top) = bottom.
            oppositeDirection(A) = B if oppositeDirection(B) = A.

            oppositeAxis(x) = y.
            oppositeAxis(y) = x.
        
            axis(left) = x.
            axis(right) = x.
            axis(top) = y.
            axis(bottom) = y.

            % directionFactor represent the notion that to move right
            % along the X axis is to move a positive amount, while to
            % move left is to move a negative amount (etc. for the Y axis).
            directionFactor(right) = 1.
            directionFactor(left) = -1.
            directionFactor(bottom) = 1.
            directionFactor(top) = -1.
    
            %%%%%% Fluent relationships. %%%%%%%
            % Windows have four derived edges.
            edge(Win, left) = X if
                position(Win) = (X, Y).
             edge(Win, top) = Y if
                position(Win) = (X, Y).
            edge(Win, right) = X + W if
                width(Win) = W.
            edge(Win, bottom) = Y + H if
                height(Win) = H.
            
            % Windows A and B are onSameLine w.r.t. an axis Axis iff there
            % is a line perpendicular to Axis A that crosses both A and B.
            %
            % For the X axis, this will hold if the following are true:
            % - The coordinate of the left edge of A is less than coordinate
            %   of the right edge of B.
            % - The coordinate of the right edge of A is greater than the coordinate
            %   of the left edge of B.
            %
            % The derivation for Y simply switches left for top and right for bottom.
            onSameLine(A, B, Axis) if
                edge(A, Direction) = A1,
                oppositeDirection(Direction) = Opposite
                edge(A, Opposite) = A2,
                edge(B, Direction) = B1,
                edge(B, Opposite) = B2,
                A != B,
                A1 < B2,
                A2 > B1.
            % onSameLine is a symmetric relationship.
            onSameLine(A, B, Axis) if onSameLine(B, A, Axis).
            
            % Two windows A and B overlap iff they are onSameLine w.r.t to both the 
            % X and Y axes.
            overlap(A, B) if
                onSameLine(A, B, x),
                onSameLine(A, B, y).
            
            % The distance between two windows A and B is the length of the shortest
            % line segment that connects opposite edges on A and B (top of A to bottom of B, etc.).
            % Distance is always positive. distance is only defined if A and B are onSameLine w.r.t
            % some axis. distance is undefined if A and B overlap.
            distance(A, B) = L1 if
                direction(Dir),
                axis(Dir) = Axis,
                onSameLine(A, B, Axis),
                -overlap(A, B),
                % There are two possible values for the length of the line segments that connect
                % opposite edges. We'll call the first L1 and the second L2.
                oppositeDirection(Dir) = O,
                edge(A, Dir) = A1,
                edge(B, O) = B1,
                L1 = A1 - B1,
                edge(A, O) = A2,
                edge(B, Dir) = B2,
                L2 = A2 - B2,
                % L1 is the distance iff L1 is less than L2.
                L1 < L2.

            % Given windows A and B, the nearestEdge of A is edge closest to B.
            % nearestEdge is only defined when there is some distance between A and B.
            nearestEdge(A, B) = right if
                distance(A, B) = D,
                edge(A, left) = E1,
                edge(B, left) = E2,
                E1 < E2.

            nearestEdge(A, B) = bottom if
                distance(A, B),
                edge(A, top) = E1,
                edge(B, top) = E2,
                E1 < E2.
            
            nearestEdge(A, B) = Dir if
                oppositeDirection(Dir) = O
                nearestEdge(B, A, O).

            % Given windows A and B, A canSnap to B if the the distance between A
            % and B is less than or equal to the snapping threshold and there is no other window C
            % that is closer to A.
            %
            % To determine the last condition, we define cannotSnap, which is true if there is some C closer
            % to A than B.
            cannotSnap(A, B) if
                distance(A, B, Dir) = D1,
                distance(A, C, Dir) = D2,
                D2 < D1.
            
            canSnap(A, B) if
                distance(A, B, Dir) = D,
                not cannotSnap(A, B),
                D <= snapping_threshold.

            % Dragging by some offset O causes the window to be displaced by O.
            % The offset alone does not determine the windows final position, since
            % other relationships can further alter the final position.
            occurs(Drag) causes possibleCoordinate(Window, Axis) = Coord + O if
                instance(Drag, drag),
                target(Drag) = Window,
                coordinate(Window, Axis) = Coord,
                offset(Drag, Axis) = O.

            % If, after dragging a window, the window cannotSnap to another window, then the
            % final coordinates are identical to the possibleCoordinates.
            coordinate(Window, Axis) if
                possibleCoordinate(Window, Axis),
                window(OtherWindow),
                not canSnap(Window, OtherWindow).

            % If, after dragging window A, A canSnap to another window B, the final coordinates
            % of A are obtained by moving A by the distance between A and B in the direction of
            % the nearestEdge of A to B.
            coordinate(A, Axis) = FinalCoord if
                possibleCoordinate(A, Axis) = Coord,
                window(B),
                canSnap(A, B),
                distance(A, B) = Distance,
                nearestSide(A, B) = Dir,
                axis(Direction) = Axis,
                directionFactor(Dir) = F,
                FinalCoor = Coord + Distance * F.

            % When a window snaps to another window, it only moves along a single axis. That is,
            % only one coordinate is changed from it possibleCoordinate value.
            % (I don't know how best to capture this notion. It feels like something that should
            % be represented by inertia. If snapping only changes one coordinate value why should it
            % be necessary to say the other coordinate value has not changed?
            %
            % In the version that represented coordinates as a pair, I did not have this problem;
            % however, the present version is much cleaner over all, so I happy to make this trade-off.
            % Still, can you think of any cleaner solutions?)
            coordinate(A, OppositeAxis) = Coord if
                possibleCoordinate(A, Axis) = Coord,
                window(B),
                canSnap(A, B),
                nearestSide(A, B) = Dir,
                axis(Dir) = Axis,
                oppositeAxis(Axis) = OppositeAxis
