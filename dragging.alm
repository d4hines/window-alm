theory window_motion
    module dragging
        sort declarations
            windows :: universe
            % directions is a set comprised of the atoms left, right, top, and bottom.
            directions :: { left, right, top, bottom }
            % axes is a set comprised of the atoms x and y.
            axes :: { x, y }
            drag :: actions
                attributes
                    target : windows
                    diff : (integers, integers)
            snap :: actions
                attributes
                    target : windows
        function declarations
            statics
                oppositeDir : directions -> directions
                oppositeAxis : axes -> axes
                axis : edge -> axes
                comparisonFactor : directions -> { -1, 1}
            fluents
                basic
                    total id : windows -> integers
                    total position : windows -> (integers, integers)
                    total width : windows -> integers
                    total height : windows -> integers
                defined
                    total edge : windows x directions -> integers
                    total distance : windows x windows x directions -> integers
                    total aligned : windows x windows x axes -> booleans
                    notClosest : windows x windows x directions -> booleans
                    closestAligned : windows x windows x directions -> booleans
        axioms
            %%%%% Static relationships %%%%%%
            % (I'm not sure where these go)

            oppositeDir(left) = right.
            oppositeDir(top) = bottom.
            oppositeDir(A) = B if oppositeDir(B) = A.

            oppositeAxis(x) = y.
            oppositeAxis(y) = x.
        
            axis(left) = x.
            axis(right) = x.
            axis(top) = y.
            axis(bottom) = y.

            comparisonFactor(left) = -1.
            comparisonFactor(top) = -1.
            comparisonFactor(right) = 1.
            comparisonFactor(bottom) = 1.

            %%%%%% Truely fluent relationships. %%%%%%%

            % Windows have four derived edges.
            edge(Win, left) = X if
                position(Win) = (X, Y).
             edge(Win, top) = Y if
                position(Win) = (X, Y).
            edge(Win, right) = X + W if
                width(Win) = W.
            edge(Win, bottom) = Y + H if
                height(Win) = H.
            
            aligned(A, B, x) if
                edge(A, left) = ALeft,
                edge(A, right) = ARight,
                edge(B, left) = BLeft,
                edge(B, right) = BRight,
                A != B,
                ALeft < BRight,
                ARight > BLeft.

            aligned(A, B, y) if
                edge(A, top) = ATop,
                edge(A, bottom) = ABottom,
                edge(B, top) = BTop,
                edge(B, bottom) = BBottom,
                A != B,
                ATop < BBottom,
                ABottom > BTop.

            % distance is the measure between windows w.r.t to oppositeDir edges.
            % distance can be negative. However, the comparisonFactor is used to
            % relativize the distance w.r.t the direction Dir. For example, given
            % window A at position (0,0) with width 10, and window B at (-20, 0)
            % with width 10, the distance between A and B w.r.t left is 10, while
            % distance between B and A w.r.t left is -20.
            distance(A, B, Dir) = D if
                edge(A, Dir) = E1,
                oppositeDir(Dir) = O,
                edge(B, O) = E2,
                comparisonFactor(Dir) = F,
                D = (E2 - E1) * F.

            % If window B is closestAligned to window A w.r.t direction Dir,
            % then window A and B must have a non-negative distance w.r.t to Dir.
            % The axiom below is the contrapositive.
            notClosestAligned(A, B, Dir) if distance(A, B, Dir) < 0.

            % If window B is be closestAligned to window A w.r.t direction Dir,
            % then A and B must be aligned w.r.t to the axis opposite the axis of Dir.
            % The axiom below is the contrapositive.
            notClosestAligned(A, B, Dir) if
                axis(Dir) = A,
                oppositeAxis(A) = O,
                -aligned(A, B, O).
    
            % Given windows A, B, and C, if C is closer to A than B w.r.t to direction Dir,
            % then B is notClosestAligned to A w.r.t to Dir.
            notClosestAligned(A, B, Dir) if
                distance(A, B, Dir) = D1,
                distance(C, B, Dir) = D2,
                axis(Dir) = A,
                oppositeAxis(A) = O,
                aligned(A, B, O),
                | D2 | < | D1 |.
    
            %(Should this be classical or default negation?)
            closestAligned(A, B, Dir) if not notClosestAligned(A, B Dir).

            % If no windows are in snapping range, the drag is normal.
            occurs(X) causes position(Window) = (X + XDiff, Y + YDiff) if 
                instance(X, drag),
                target(X) = Window,
                diff(X) = (XDiff, YDiff).
            
            occurs(X) triggers snap(Window)
                instance(X, drag),
                target(X) = Window.
            

            % (The next two are identical except one is for X,
            % and the other is for Y. Is there a way to consolidate?)
            occurs(X) causes position(Window) = (X + Diff, Y)
                instance(X, drag),
                target(X) = Window,
                position(Window) = (X, Y).
                closestAligned(Window, SnapTarget, Dir),
                oppositeDir(Dir) = O,
                edge(Window, Dir) = WindowEdge,
                edge(SnapTarget, O) = SnapTargetEdge,
                Diff = SnapTargetEdge - WindowEdge,
                axis(Dir) = x.

            occurs(X) causes position(Window) = (X, Y + Diff)
                instance(X, drag),
                target(X) = Window,
                position(Window) = (X, Y).
                closestAligned(Window, SnapTarget, Dir),
                oppositeDir(Dir) = O,
                edge(Window, Dir) = WindowEdge,
                edge(SnapTarget, O) = SnapTargetEdge,
                Diff = SnapTargetEdge - WindowEdge,
                axis(Dir) = y.
